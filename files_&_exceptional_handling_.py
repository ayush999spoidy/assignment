# -*- coding: utf-8 -*-
"""Files & Exceptional Handling .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BbIsadM_sqcjNy73zwNui7DzIEyn4J93

1. Discuss the scenarios where multithreading is preferable to multiprocessing and scenarios where
multiprocessing is a better choice.

Ans. Multithreading --- Multithreading is ideal when tasks are I/O-bound and require frequent I/O operations, such as reading from a disk, network communication, or database access. Threads share memory within a process, making it easier to share data and communicate without complex inter-process communication.	Efficiently handles I/O without waiting, minimal memory overhead
Keeps the application responsive during background tasks.Threads share memory, simplifying data sharing


Multiprocessing--- Multiprocessing is better suited for CPU-bound tasks that require extensive computations and can take advantage of multiple CPU cores.
Processes have separate memory spaces, reducing contention.
Isolates tasks so failure in one doesn’t affect others.Allows parallel execution across CPU cores without GIL interference

2.Describe what a process pool is and how it helps in managing multiple processes efficiently

Ans.A process pool is ideal for cases where you have many similar, independent tasks that can be divided into smaller chunks,Performing data transformations on large datasets.Running multiple CPU-bound tasks simultaneously.Repeatedly calling a function on a set of inputs By managing processes efficiently, a process pool simplifies parallel processing and enhances performance in applications that benefit from concurrent execution.
"""

from multiprocessing import Pool
def compute_square(number):
    return number * number

with Pool(processes=4) as pool:
  results = pool.map(compute_square, [1, 2, 3, 4, 5])

  print(results)

"""3. Explain what multiprocessing is and why it is used in Python programs

Ans.Multiprocessing is a powerful tool in Python for leveraging multiple CPU cores, bypassing the GIL, and running tasks in parallel. It is especially useful for computationally intensive programs that can be divided into smaller, independent tasks, improving the overall efficiency and responsiveness of Python applications.
"""

from multiprocessing import Process
def compute_square(number):
    print(f"The square of {number} is {number * number}")
if __name__ == '__main__':
    processes = []
    for i in range(5):
        process = Process(target=compute_square, args=(i,))
        processes.append(process)
        process.start()
    for process in processes:
        process.join()

"""4. Write a Python program using multithreading where one thread adds numbers to a list, and another
thread removes numbers from the list. Implement a mechanism to avoid race conditions using
threading.Lock.

"""

import threading
import time
import random
shared_list = []
list_lock = threading.Lock()
def add_numbers():
    for i in range(10):
        list_lock.acquire()
        try:
            number = random.randint(1, 100)
            shared_list.append(number)
            print(f"Added: {number}")
        finally:
          list_lock.release()
          time.sleep(random.uniform(0.1, 0.5))

def remove_numbers():
    for _ in range(10):
        with list_lock:
            if add_numbers:
                removed_num = add_numbers.pop(0)
                print(f"Removed {removed_num} from the list.")
            else:
                print("List is empty, nothing to remove.")
        time.sleep(random.uniform(0.1, 0.5))

add_thread = threading.Thread(target=add_numbers)
remove_thread = threading.Thread(target=remove_numbers)
add_thread.start()
remove_thread.start()
add_thread.join()
remove_thread.join()
print("Final list:", remove_thread)

"""5. Describe the methods and tools available in Python for safely sharing data between threads and
processes

Ans. threading.Lock --Basic locking mechanism

threading.RLock-- Reentrant locking


threading.Condition--Coordination between threads

threading.Event-- Signaling between threads

threading.Semaphore-- Limiting concurrent access

Queue--Thread-safe FIFO queue

multiprocessing.Manager--Shared objects between processes

multiprocessing.Value--Single shared value

multiprocessing.Array--Shared array

multiprocessing.Lock--Locking mechanism for processes

multiprocessing.Event--Signaling between processes

multiprocessing.Pipe--Two-way communication

multiprocessing.Queue--Process-safe FIFO queue

6. Discuss why it’s crucial to handle exceptions in concurrent programs and the techniques available for
doing so

Ans. Handling exceptions in concurrent programs is crucial to ensure stability, prevent data corruption, and maintain expected behavior. In concurrent environments (such as multithreading and multiprocessing), unhandled exceptions in one thread or process can lead to incomplete operations, deadlocks, resource leaks, and even the unexpected termination of other threads or processes.Catches exceptions locally within threads/processes.Catches exceptions from tasks submitted to pools.Centralized exception handling in all threads.Ensures cleanup of resources, even with exceptions.Logs exceptions for easier monitoring and debugging

7.Create a program that uses a thread pool to calculate the factorial of numbers from 1 to 10 concurrently.
Use concurrent.futures.ThreadPoolExecutor to manage the threads

Ans.
"""

from concurrent.futures import ThreadPoolExecutor, as_completed

# function to calcu factorial
def factorial(n):
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# List of numbers to calculate factorial for
numbers = range(1, 11)

# Using ThreadPoolExecutor to manage threads
with ThreadPoolExecutor() as executor:
    # Submit factorial tasks to the thread pool
    futures = {executor.submit(factorial, num): num for num in numbers}

    # Process results as they complete
    for future in as_completed(futures):
        num = futures[future]
        try:
            result = future.result()
            print(f"Factorial of {num} is {result}")
        except Exception as e:
            print(f"An error occurred calculating factorial of {num}: {e}")

"""8.Create a Python program that uses multiprocessing.Pool to compute the square of numbers from 1 to 10 in
parallel. Measure the time taken to perform this computation using a pool of different sizes (e.g., 2, 4, 8
processes).
"""

import multiprocessing
import time

# Function to compute the square of a number
def square(n):
    return n * n

# List of numbers to compute squares for
numbers = range(1, 11)

# Function to measure time taken to compute squares with a specified pool size
def compute_squares_with_pool(pool_size):
    start_time = time.time()
    with multiprocessing.Pool(pool_size) as pool:
        results = pool.map(square, numbers)
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Pool size {pool_size}: Computed squares {results} in {elapsed_time:.4f} seconds")

# Testing with different pool sizes
for pool_size in [2, 4, 8]:
    compute_squares_with_pool(pool_size)

